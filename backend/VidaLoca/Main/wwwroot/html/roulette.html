<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>VidaLoca — Roulette</title>
  <link rel="stylesheet" href="../css/style.css" />
    <!-- Inline fallback styles to ensure pointer/table visible while debugging -->
    <script>
      // debug log; keep minimal to avoid inline styling
      window.addEventListener('DOMContentLoaded', ()=>{
        console.log('roulette debug:', {
          wheelCanvas: !!document.getElementById('roulette'),
          betGrid: !!document.getElementById('betGrid'),
          betsCard: !!document.querySelector('.bets-card')
        });
      });
    </script>
  </head>
  <body>
    <header class="site-header">
      <div class="container center">
        <h1 class="site-title">VidaLoca</h1>
      </div>
    </header>

    <main class="container home-main center">
      <div class="roulette-wrap">
        <section class="wheel-area">
          <div class="wheel-stage">
            <canvas id="roulette" width="520" height="520" aria-label="Roulette wheel"></canvas>
            <div class="wheel-pointer"></div>
          </div>
          <div class="controls">
            <button id="spinBtn" class="btn btn-primary">Spin</button>
            <button id="resetBtn" class="btn btn-ghost">Reset Bets</button>
            <p id="result" class="small muted mt-1">Place your bets and spin the wheel.</p>
          </div>
        </section>

        <aside class="bets-area">
          <div class="bets-card">
            <h3>Betting Table</h3>
            <div class="chips-row">
              <button class="chip" data-value="1">1</button>
              <button class="chip" data-value="5">5</button>
              <button class="chip" data-value="10">10</button>
              <button class="chip" data-value="25">25</button>
            </div>

            <!-- red/black column will occupy the 4th column of the bet grid -->

            <div id="usernameView" class="username"></div>
            <div id="balanceView" class="balance">Balance: -- €</div>

            <div class="bet-grid-wrap">
              <div class="bet-grid" id="betGrid" aria-label="Betting grid">
                <!-- numbers 0-36 will be generated by script -->
              </div>

              <!-- fourth column: thin tall red/black buttons -->
              <div class="bet-column-vertical">
                <button id="betRed" class="bet-color-tall btn-red">RED</button>
                <button id="betBlack" class="bet-color-tall btn-black">BLACK</button>
              </div>
            </div>

            <div class="mt-1">
              <button id="placeBetBtn" class="btn btn-primary">Place Selected Bet</button>
            </div>
            <div class="mt-1">
              <a class="btn btn-ghost" href="/html/games.html">Back to Games</a>
            </div>
          </div>
        </aside>
      </div>
    </main>

    <footer class="site-footer center">
      <div class="container">
        <p class="small">© 2025 VidaLoca — All rights reserved</p>
      </div>
    </footer>
    <script>
      // Simple roulette wheel logic (visual + basic bets)

      // Resolve accountId from localStorage or by calling GetAccountByEmail using the logged-in email
      async function resolveAccountId() {
        const stored = localStorage.getItem('accountId');
        if (stored) return Number(stored);
        const email = localStorage.getItem('VidaLoca/loggedInEmail');
        if (!email) return null;
        try {
          const resp = await fetch(`/Account/GetAccountByEmail?email=${encodeURIComponent(email)}`);
          if (!resp.ok) return null;
          const acct = await resp.json();
          if (acct && acct.accountId) {
            localStorage.setItem('accountId', String(acct.accountId));
            if (acct.username) localStorage.setItem('VidaLoca/loggedInUsername', acct.username);
            return Number(acct.accountId);
          }
        } catch (e) { /* ignore */ }
        return null;
      }

      async function showBalance(){
        const id = await resolveAccountId();
        const el = document.getElementById('balanceView');
        const userEl = document.getElementById('usernameView');
        const storedName = localStorage.getItem('VidaLoca/loggedInUsername');
        if (userEl) userEl.innerText = storedName ? storedName : '';
        if (!id) { if (el) el.innerText = 'Balance: - (not logged)'; return; }
        try {
          const res = await fetch(`/Account/GetBalanceByAccount?accountId=${id}`);
          if (!res.ok) { if (el) el.innerText = 'Balance: -'; return; }
          const b = await res.json();
          if (el) el.innerText = 'Balance: ' + Number(b).toFixed(2) + ' €';
        } catch (e) { if (el) el.innerText = 'Balance: -'; }
      }
      (function(){
        const canvas = document.getElementById('roulette');
        const ctx = canvas.getContext('2d');
        const size = Math.min(canvas.width, canvas.height);
        const center = { x: canvas.width/2, y: canvas.height/2 };
        const radius = size/2 - 6;

        // Roulette sequence 
        const numbers = [0,32,15,19,4,21,2,25,17,34,6,27,13,36,11,30,8,23,10,5,24,16,33,1,20,14,31,9,22,18,29,7,28,12,35,3,26];
        const colors = { red: '#d32f2f', black: '#111', green: '#1b5e20' };

        function drawWheel(rotation=0){
          ctx.clearRect(0,0,canvas.width,canvas.height);
          const slice = (2*Math.PI) / numbers.length;
          ctx.save();
          ctx.translate(center.x, center.y);
          ctx.rotate(rotation);

          for(let i=0;i<numbers.length;i++){
            const start = i*slice;
            const end = start + slice;
            // choose color
            const n = numbers[i];
            const color = n === 0 ? colors.green : (isRed(n) ? colors.red : colors.black);
            ctx.beginPath();
            ctx.moveTo(0,0);
            ctx.arc(0,0,radius,start,end);
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
            // border
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 2;
            ctx.stroke();

            // number label: compute absolute position instead of translating the context
            const labelAngle = rotation + start + slice/2;
            const labelRadius = radius * 0.9;
            const lx = Math.cos(labelAngle) * labelRadius;
            const ly = Math.sin(labelAngle) * labelRadius;
            ctx.save();

            ctx.setTransform(1, 0, 0, 1, 0, 0); // reset transform
            ctx.translate(center.x + lx, center.y + ly);
            ctx.rotate(labelAngle + Math.PI/2);
            ctx.fillStyle = '#fff';
            ctx.font = '18px Inter, system-ui, -apple-system, Roboto, Arial';
            ctx.textAlign = 'center';
            ctx.fillText(String(n), 0, 0);
            ctx.restore();
          }

          // center hub 
          ctx.beginPath();
          ctx.arc(0,0,32,0,2*Math.PI);
          ctx.fillStyle = '#222';
          ctx.fill();
          ctx.restore();
        }

        function isRed(n){
          // red numbers set from standard roulette
          const reds = new Set([1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36]);
          return reds.has(n);
        }

        // initial draw
        drawWheel(0);

  // bets UI
  const betGrid = document.getElementById('betGrid');
  if(!betGrid) console.warn('betGrid element not found; betting UI will not initialize');
        const chips = Array.from(document.querySelectorAll('.chip'));
        let selectedChip = null;
        let pendingBets = {}; // number -> amount

        function createBetCells(){
          // create 0 cell as a wide top cell
          const zeroBtn = document.createElement('button');
          zeroBtn.className = 'bet-cell bet-cell-zero';
          zeroBtn.dataset.num = '0';
          zeroBtn.innerHTML = '<span class="num">0</span><span class="badge" aria-hidden="true"></span>';
          zeroBtn.addEventListener('click', () => applyBetToCell(zeroBtn, 0));
          betGrid.appendChild(zeroBtn);

          // create numbers 1..36 in 3 columns layout visually (we rely on CSS)
          for(let i=1;i<=36;i++){
            const btn = document.createElement('button');
            btn.className = 'bet-cell';
            btn.dataset.num = String(i);
            const colorClass = isRed(i) ? 'num-red' : 'num-black';
            btn.innerHTML = `<span class="num ${colorClass}">${i}</span><span class="badge" aria-hidden="true"></span>`;
            btn.addEventListener('click', ()=> applyBetToCell(btn, i));
            betGrid.appendChild(btn);
          }
        }

        function applyBetToCell(cell, number){
          if(!betGrid) return;
          if(!selectedChip) return;
          const val = parseInt(selectedChip.dataset.value,10);
          pendingBets[number] = (pendingBets[number]||0) + val;
          cell.classList.add('bet-placed');
          const b = cell.querySelector('.badge');
          if(b) {
            b.innerText = pendingBets[number];
            // visuals handled by CSS classes
          }
        }
        createBetCells();

        chips.forEach(c=> c.addEventListener('click', ()=>{
          chips.forEach(x=> x.classList.remove('chip-selected'));
          c.classList.add('chip-selected');
          selectedChip = c;
        }));

        // color bets state (red / black tall buttons)
        let colorBets = { red: 0, black: 0 };
        const betRedBtn = document.getElementById('betRed');
        const betBlackBtn = document.getElementById('betBlack');

        function updateColorButtonUI(){
          if(betRedBtn) betRedBtn.innerText = colorBets.red > 0 ? `RED \n${colorBets.red}` : 'RED';
          if(betBlackBtn) betBlackBtn.innerText = colorBets.black > 0 ? `BLACK \n${colorBets.black}` : 'BLACK';
        }

        if(betRedBtn) betRedBtn.addEventListener('click', ()=>{
          if (!selectedChip) return;
          const val = Number(selectedChip.dataset.value);
          colorBets.red += val;
          updateColorButtonUI();
          document.getElementById('result').innerText = 'Placed red bet: ' + colorBets.red;
        });
        if(betBlackBtn) betBlackBtn.addEventListener('click', ()=>{
          if (!selectedChip) return;
          const val = Number(selectedChip.dataset.value);
          colorBets.black += val;
          updateColorButtonUI();
          document.getElementById('result').innerText = 'Placed black bet: ' + colorBets.black;
        });

        document.getElementById('placeBetBtn').addEventListener('click', ()=>{
          document.getElementById('result').innerText = 'Bets placed: ' + Object.keys(pendingBets).length;
        });

        document.getElementById('resetBtn').addEventListener('click', ()=>{
          pendingBets = {};
          document.querySelectorAll('.bet-cell').forEach(b=>{
            b.classList.remove('bet-placed');
            const badge = b.querySelector('.badge');
            if(badge) {
              badge.innerText='';
              // reset visuals via CSS by removing parent class
            }
            delete b.dataset.amount;
          });
          document.getElementById('result').innerText = 'Bets reset.';
        });

        // Spin animation: rotate to a random target number
        const spinBtn = document.getElementById('spinBtn');
        let spinning = false;

        async function postUpdateBet(amount, operation, email){
          try{
            const res = await fetch('/Account/UpdateBetMoney', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ Amount: amount, Operation: operation, Email: email })
            });
            return res.ok;
          }catch(e){ return false; }
        }

        function clearPlacedBetsUI(){
          // clear number bet badges
          document.querySelectorAll('.bet-cell').forEach(b=>{
            b.classList.remove('bet-placed','bet-win');
            const badge = b.querySelector('.badge');
            if(badge) badge.innerText = '';
          });
          // clear client-side state
          pendingBets = {};
          colorBets = { red: 0, black: 0 };
        }

        spinBtn.addEventListener('click', async ()=>{
          if(spinning) return;

          // compute total stake
          const numStake = Object.values(pendingBets).reduce((s,v)=> s + Number(v||0), 0);
          const colorStake = (Number(colorBets.red||0) + Number(colorBets.black||0));
          const totalStake = numStake + colorStake;

          const email = localStorage.getItem('VidaLoca/loggedInEmail');
          if(totalStake > 0 && !email){
            document.getElementById('result').innerText = 'Please login to place bets.';
            return;
          }

          // if there's a stake, subtract it before spinning
          if(totalStake > 0){
            const ok = await postUpdateBet(totalStake, false, email);
            if(!ok){
              document.getElementById('result').innerText = 'Bet failed: insufficient funds or server error.';
              return;
            }
            // immediately refresh balance so user sees the deducted amount during the spin
            if (typeof showBalance === 'function') await showBalance();
          }

          // disable betting UI while spinning
          const controls = Array.from(document.querySelectorAll('.chip, .bet-cell, #betRed, #betBlack, #placeBetBtn, #resetBtn'));
          controls.forEach(c => c.setAttribute('disabled','true'));
          spinBtn.setAttribute('disabled','true');
          spinning = true;
          const spins = 6 + Math.floor(Math.random()*6); // full rotations
          const winningIndex = Math.floor(Math.random()*numbers.length);
          const slice = (2*Math.PI) / numbers.length;
          // we want pointer at top (angle -PI/2), wheel rotated so slice center aligns
          const targetRotation = ( - (winningIndex + 0.5) * slice ) + (-Math.PI/2);
          const start = 0;
          const duration = 3500 + Math.random()*1200;
          const final = targetRotation - (spins * 2*Math.PI);

          const startTime = performance.now();
          const resultEl = document.getElementById('result');
          function animate(now){
            const t = Math.min(1, (now - startTime)/duration);
            // ease out cubic
            const eased = 1 - Math.pow(1-t,3);
            const current = start + (final - start) * eased;
            drawWheel(current);
            if(t < 1) requestAnimationFrame(animate);
            else {
              (async ()=>{
                spinning = false;
                const winNum = numbers[winningIndex];
                resultEl.innerText = 'Result: ' + winNum;
                // highlight winning cell
                document.querySelectorAll('.bet-cell').forEach(b=> b.classList.toggle('bet-win', parseInt(b.dataset.num,10)===winNum));

                // compute payouts
                let totalWin = 0;
                const betOnNumber = Number(pendingBets[winNum] || 0);
                if(betOnNumber > 0) totalWin += betOnNumber * 36;
                if(winNum !== 0){
                  const winColor = isRed(winNum) ? 'red' : 'black';
                  const colorBet = Number(colorBets[winColor] || 0);
                  if(colorBet > 0) totalWin += colorBet * 2;
                }

                if(totalWin > 0 && email){
                  const okAdd = await postUpdateBet(totalWin, true, email);
                  if(okAdd){
                    resultEl.innerText += ' — You won: ' + totalWin + ' €';
                  } else {
                    resultEl.innerText += ' — Server error applying winnings.';
                  }
                } else if(totalStake > 0){
                  resultEl.innerText += ' — No win.';
                }
                // clear bets UI and state (graphical reset)
                clearPlacedBetsUI();
                updateColorButtonUI();

                // refresh balance after updates
                if (typeof showBalance === 'function') await showBalance();

                // re-enable controls
                controls.forEach(c => c.removeAttribute('disabled'));
                spinBtn.removeAttribute('disabled');
              })();
            }
          }
          requestAnimationFrame(animate);
        });

        // fetch balance on initial load
        if (typeof showBalance === 'function') showBalance();

      })();
    </script>
  </body>
</html>
